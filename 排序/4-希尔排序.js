// 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。
// 是非稳定排序算法，插入排序只能移动一个相邻位置，希尔排序优化了这一点（希尔排序可以一次移动 gap 个距离），
// 利用了插入排序的特点，在数组本身就是 基本有序 以及 元素个数 较少时，它的效率是很高的。
// 希尔排序是基于插入排序的以下两点性质而提出改进方法的：

// 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序 O(n) 的效率；
// 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
// https://juejin.cn/post/6844903628935806984 
// https://static.kancloud.cn/fortheday/js-data-structure-and-algorithm/1698055
// b站看视频理解更好
// 希尔排序的基本思想是：先将整个待排序的序列分割成为若干子序列（不是真的分割，是看成分割）分别进行直接插入排序，
// 待整个序列中的记录“基本有序”时，再对全体进行直接插入排序。

const arr1 = [3,6,9,1,5,4,2];

function shellSort(arr) {
    // 计算跨度
    let gap = parseInt(arr.length/2)
    // 保存临时数据
    let tmp
    // 当跨度大于0时（跨度每次减半）
    while(gap>0) {
        /* 对每个跨度对应的组执行 “插入排序” */
        // 插入排序是从第2 个元素开始向前面的比较
        // 所以这里开始的元素是 gap （向后一个跨度）即第2个元素
        // 下面的代码其实和插入排序相差无几，区别就是插入排序的代码gap是1，而这里的gap是变化的
        for(let i=gap; i<arr.length; i++) {
            // 保存当前元素
            temp = arr[i];
            // 前一个比较元素的索引 
            let preIndex = i - gap;
            // 如果前一个元素大于这个元素，那么前一个元素就向后挪一位
            // 直到一个不大于当前元素的就退出循环（不需要再向前比较了）
            while (preIndex >=0 && arr[preIndex]>temp) {
                arr[preIndex+gap] = arr[preIndex];
                preIndex -=gap; 
            }
            // 把当前元素放到不大于它的这个元素的后面
            arr[preIndex+gap] = temp;
        }
        // 跨度减小一半
        gap = parseInt(gap/2)
    }
    return arr;
}
